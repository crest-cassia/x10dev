package tekram.util;
import x10.io.File;
import x10.util.ArrayList;
import x10.util.HashMap;
import x10.util.List;
import x10.util.Map;
import x10.util.StringBuilder;

/**
 * A JSON parser with restrictions:
 *
 *     * no type recognition for literals (stored as string)
 *     * no escape sequence handling
 * 
 * Syntax:  json := object
 *          name := ( string | literal )
 *          value := ( object | array | string | literal )
 *          object := "{" [ name ":" value [ "," name ":" value ]* ] "}"
 *          array := "[" [ value [ "," value ]* ] "]"
 *          string := QUOTE [ CHARACTER ]* QUOTE
 *          literal := ( LETTERS | DIGITS | "_" | "." | "+" | "-" )+
 */
public class JSON {

	public static class Value {
		
		public static NULL = new Value(null);

		var value:Any;

		public def this(value:Any) {
			this.value = value;
		}

		public def get[T](s:T):Value {
			if (!this.has(s)) {
				return NULL;
			}
			if (this.isList()) {
				val i = Long.parse(s.toString());
				return this.asList()(i);
			}
			if (this.isMap()) {
				return this.asMap().get(s.toString())();
			}
			return NULL;
		}

		public def get[T](s:Rail[T]):Value {
			var v:Value = this;
			for (i in 0..(s.size - 1)) {
				if (v.has(s(i))) {
					v = v.get(s(i));
				} else {
					return NULL;
				}
			}
			return v;
		}

		public def any[T](s:Rail[T]):Value {
			for (i in 0..(s.size - 1)) {
				if (this.has(s(i))) {
					return this.get(s(i));
				}
			}
			return NULL;
		}

		public def has[T](s:T):Boolean {
			if (this.isList()) {
				val i = Long.parse(s.toString());
				return 0 <= i && i < this.asList().size();
			}
			if (this.isMap()) {
				return this.asMap().containsKey(s.toString());
			}
			return false;
		}

		public def size():Long {
			if (this.isList()) {
				return this.asList().size();
			}
			if (this.isMap()) {
				return this.asMap().size();
			}
			return 0;
		}

		public operator this[T](s:T):Value {
			return this.get(s);
		}

		public operator this[T](s:Rail[T]):Value {
			return this.any(s);
		}

		public def isNull():Boolean {
			return this.value == null;
		}

		public def isMap():Boolean {
			return this.value instanceof Map[String,Value];
		}

		public def asMap():Map[String,Value] {
			return this.value as Map[String,Value];
		}

		public def isList():Boolean {
			return this.value instanceof List[Value];
		}

		public def asList():List[Value] {
			return this.value as List[Value];
		}

		public def toString():String {
			return this.value as String;
		}

		public def toBoolean():Boolean {
			return Boolean.parse(this.value as String);
		}

		public def toInt():Int {
			return Int.parse(this.value as String);
		}

		public def toLong():Long {
			return Long.parse(this.value as String);
		}

		public def toDouble():Double {
			return Double.parse(this.value as String);
		}
	}

	static class Stream {
		
		public var text:String;
		public var i:Int;

		public def this(text:String) {
			this.text = text;
			this.i = 0n;
		}

		public def get():Char {
			return this.text(this.i);
		}

		public def next() {
			this.i++;
		}
	}

	static class SyntaxException extends Exception {
		
		public def this(p:Stream) {
			super(p.text.substring(Math.max(0n, p.i - 20n), Math.min(p.i + 20n, p.text.length())));
		}
	}

	public static def isJSONLetter(p:Stream) {
		val c = p.get();
		return (c.isLetter() || c.isDigit() || c == '_' || c == '.' || c == '+' || c == '-');
	}

	public static def isJSONQuote(p:Stream) {
		val c = p.get();
		return (c == '"' || c == '\''); //"
	}

	public static def skipSpaces(p:Stream) {
		while (p.get().isWhitespace()) {
			p.next();
		}
	}

	public static def parseLiteral(p:Stream):String {
		val b = p.i;

		while (isJSONLetter(p)) {
			p.next();
		}
		if (b == p.i) {
			throw new SyntaxException(p);
		}
		return p.text.substring(b, p.i);
	}

	public static def parseString(p:Stream):String {
		val quote = p.get();
		if (isJSONQuote(p)) {
			p.next();
		} else {
			throw new SyntaxException(p);
		}

		val b = p.i;

		while (p.i < p.text.length()) {
			if (p.get() == quote) {
				p.next();
				break;
			} else {
				p.next();
			}
		}
		if (p.i >= p.text.length()) {
			throw new SyntaxException(p);
		}
		return p.text.substring(b, p.i - 1n);
	}

	public static def parseValue(p:Stream):Any {
		if (p.get() == '{') {
			return parseObject(p);
		} else if (p.get() == '[') {
			return parseArray(p);
		} else if (isJSONQuote(p)) {
			return parseString(p);
		} else {
			return parseLiteral(p);
		}
	}

	public static def parseName(p:Stream):String {
		if (isJSONQuote(p)) {
			return parseString(p);
		} else {
			return parseLiteral(p);
		}
	}

	public static def parseObject(p:Stream):Map[String,Value] {
		val a = new HashMap[String,Value]();

		if (p.get() == '{') {
			p.next();
		} else {
			throw new SyntaxException(p);
		}

		skipSpaces(p);
		if (p.get() == '}') {
			p.next();
			return a;
		}

		while (true) {
			skipSpaces(p);
			val s = parseName(p);

			skipSpaces(p);
			if (p.get() == ':') {
				p.next();
			} else {
				throw new SyntaxException(p);
			}

			skipSpaces(p);
			val v = parseValue(p);

			a.put(s, new Value(v));

			skipSpaces(p);
			if (p.get() == ',') {
				p.next();
			} else {
				break;
			}
		}

		skipSpaces(p);
		if (p.get() == '}') {
			p.next();
		} else {
			throw new SyntaxException(p);
		}
		return a;
	}

	public static def parseArray(p:Stream):List[Value] {
		val a = new ArrayList[Value]();

		if (p.get() == '[') {
			p.next();
		} else {
			throw new SyntaxException(p);
		}

		skipSpaces(p);
		if (p.get() == ']') {
			p.next();
			return a;
		}

		while (true) {
			skipSpaces(p);
			val v = parseValue(p);

			a.add(new Value(v));

			skipSpaces(p);
			if (p.get() == ',') {
				p.next();
			} else {
				break;
			}
		}

		skipSpaces(p);
		if (p.get() == ']') {
			p.next();
		} else {
			throw new SyntaxException(p);
		}
		return a;
	}

	public static def parse(text:String) {
		val p = new Stream(text);
		skipSpaces(p);
		val v = parseObject(p);
		return new Value(v);
	}

	public static def parse(file:File) {
		val s = new StringBuilder();
		for (line in file.lines()) {
			s.add(line);
			s.add(" ");
		}
		return parse(s.toString());
	}

	public static def main(args:Rail[String]) {
//		val json = JSON.parse("{'first': 1, 'second': 2, 'third': [1,2,'c'], '4th': {'one': { 'more': b.c.c } }, nullobj: { }, 1  : [],  spaces  : 'a a a'    ,   123   : 123  }");
		val json = JSON.parse(new File("tekram/util/sample.json"));
		Console.OUT.println(json.size());
		Console.OUT.println(json("first").size());
		Console.OUT.println(json("third").size());
		Console.OUT.println(json("first"));
		Console.OUT.println(json("first").toString());
		Console.OUT.println(json("third")(1).toLong());
		Console.OUT.println(json("third")("1").toLong());
		Console.OUT.println(json("third")("1").toDouble());
		Console.OUT.println(json("third")("2").toString());
		Console.OUT.println(json("4th")("one")("more").toString());
		Console.OUT.println(json.get(["third", 2]).toString());
		Console.OUT.println(json.get(["third", "2"]).toString());
		Console.OUT.println(json.get(["4th", "one", "more"]).toString());
		Console.OUT.println(json.get(["4th", "onetwo", "more"]));
		Console.OUT.println(json("4th")("onetwo")("more"));
		Console.OUT.println(json("4th").any(["three", "two"]).get("more"));
		Console.OUT.println(json("4th")(["three", "two"])("more").toString());
	}
}
